    目前，计算机已经是多处理器，性能较之以前已经有了非常大的提高。为了更加充分的提高性能，在执行IO等待操作时，需要让出CPU，让CPU处理其它任务，也就是
所谓的分时系统，并发也就跟着出现了。后来出现了多核CPU又有了并行计算，也就是所谓的【分工】。分工之后为了更近一步的提升效率和达到更加灵活的目的，所以
就对任务进行了组织编排，也就是对线程的编排，于是线程间就有了通信，于是操作系统就提供了让进程，线程通信的方式-信号量和管程，也就是所谓的【同步/协作】。
线程通信时，又带来了新的问题-多线程访问共享变量（安全问题），为了解决这个问题，又对访问共享变量进行串行话，也就是所谓的【互斥】
    【原子性】，【可见性】，【顺序性】并发Buy的真正源头
    说到并发问题，都离不开CPU，内存，与IO，CPU主要用来做核心计算，内存用来存储，IO外部资源访问，三者的速度CPU>>>内存>>>>>IO，一个系统，往往都
一定会伴随的IO访问，根据水桶原则，单纯的提高CPU效率是提高不了整体计算机系统的效率的。面对这种问题，计算机系统，编译程序都给出了优化。
    CPU增加了缓存，均衡与内存间的差异。
    操作系统增加了进程，线程，以用来分时复用CPU，均衡内存与IO设备间的差异
    编译程序增加了指令重排序，使得缓存可以更加高效的利用
但是，事情往往都不是绝对美好的，并发产生的各种问题，源头也在这里。
    1.缓存导致的可见性问题
        一个变量的定义都是在内存里，CPU多核时代，每个CPU都有自己的缓存，当多个线程在不同CPU执行时，就有了多个不同的CPU缓存。举个例子，在内存中
        定义一个变量，当线程A，B访问它时，首先会将变量的当前值缓存到线程的工作缓存中去，之后线程在操作这个变量时，操作的是自己缓存中的变量，这个
        操作A，B线程是不可见的。详细来说就是，在内存中定义一个变量i=0；线程A，和线程B都对i进行+1的操作，理想状态最终i的结果是2，但结果很有可能
        会出现1的情况，建单描述下：就是线程A去读这个变量，发现是0，然后进行+1，可能这个时候线程B读到的变量也是0，也是进行了+1，因为不同线程的
        工作内存操作时不可见的，所有就有了结果可能是1的情况。
        java中提供了【volatile】来解决这个可见性的问题，在操作变量时，强制线程去中内存中同步变量的最新值，也就是解决了可见性问题，另外volatile
        还可以解决的就是指令重排问题，是通过内存屏障来实现的，具体可以看代码的volatile包下的详细说明，另外volatile解决不了原子性问题
    2.线程切换带来的原子性问题
        由于IO操作太慢，刚开始的操作系统发明了多进程，就可以一边玩游戏，一边听歌，这就是多进程的功劳。操作系统允许一个进程执行小段时间，例如50ms，
        过了50ms后，操作系统就会重新选择进程执行，这个50ms被称为【时间片】。如果在一个时间片内，一个进程执行了IO操作，那么该进程就会标记自己休眠，
        让出CPU，允许操作系统调度其它进程执行，这样一来，效率就上来了。这也是所谓的任务切换，现在说到的任务切换指的是线程切换，在同一个进程内，创建
        的所有线程是共享内存空间的。Java的并发程序也是基于多线程的，自认也会涉及到任务切换。
        任务的切换大多是在时间片接受后的，Java这种高级语言程序里一条语句都包含多个【CPU指令】，如count++，包含三个指令：
        1.将count从主内存读到线程工作内存，2.在工作内存执行+1，3.将count写到主内存
        操作系统执行任务切换，可以发生在任意一条CPU指令执行完。如果多线程环境下，执行count++，结果往往到不到预期，比如线程A，B，执行count++，当
        A执行执行到把count=0加载到工作内存的时候，这个时候发生了线程切换，线程B也将count=0加载到了工作内存，这个时候线程A，B都是基于0开始执行++的
        这个时候，结果往往达不到预期
        把一个或者多个操作在CPU的执行过程中不会被打断的特性称为原子性。很显然，count++不是原子性操作。CPU保证的原子操作是指令级别的，所有在Java里
        我们需要手动保证某些操作的原子性，也就是加锁。
    3.编译优化带来的有序性问题
        操作系统为了更进一步的提升效率，往往会在不影响程序执行结果的同时会调整程序中语句的执行顺序，如
        int a=1；
        int b=2;
        a++;
        b++;
        sout(a+b);
        如上代码，编译期可能调整代码的执行顺序，可能吧b++执行顺序调整到a++前面执行。java中有一个非常著名的单例模式-双重检索机制，具体见【volatile】
        示例代码详细讲解