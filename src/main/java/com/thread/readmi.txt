1.demo案例
2.test关键字用法

sync（Object）
锁升级
偏向锁 -> 自旋锁 -> 重量级
首先一个线程获取到一个锁，会在这个对象头记录当前线程，如果这次线程在请求这个锁对象，发现存在对象头记录，则不会加锁，这时候是偏向锁
如果另外一个线程来获取锁，发现已经有线程占用，则请求锁的这个线程会自旋，继续占用cpu时间，jdk默认自旋10次，此时就是升级到了自旋锁
如果自旋10次，获取锁的线程还是么有释放锁，则不在自旋，进入线程等待队列，升级为重量级锁

如果线程少，执行时间短，则自旋锁
如果线程很多，执行时间也很长，就选择重量级锁

内存模型JMM之互斥锁，volatiledemo介绍了volatile和Happens-Before解决可见性与顺序性问题，这里说明下互斥锁解决原子性问题。

    一个或多个操作在CPU执行过程中不被中断，称为原子性。破坏原子性的主要问题就是线程切换，而在操作系统中线程切换是依赖CPU中断的，
那么是否说明禁用CPU中断就可以解决线程切换问题。但是这种方法只适用于单核CPU，如果多核CPU的话，问题依然存在。
    我们知道。Long占8个字节，就是64位，在32位的操作系统上，写操作会被分为两次操作，【写高位和写地位】，如果在单核系统，禁用了CPU中断
一个线程就会连续的执行，所以以上两次操作要么执行要么不执行。但是在多核CPU中，禁止CPU中断只能保证多个线程同时连续执行，并不能保证
【同一时刻只有一个线程执行】。如果两个线程同时【写高位】的话，就出bug了。
    如何解决呢，上面说到，同一时刻只有一个线程执行，这个又叫做【互斥】，如果可以保证对共享变量的修改是互斥的，那么问题就可以解决了。这也是
所谓的【锁】
    简单的锁模型 【加锁】临界区 【解锁】，首先，如果一个线程想进入临界区，尝试加锁，加锁成功，进入临界区，执行完毕，解锁。但是这个过程中，
忽略了一个问题，【锁】的是什么【保护】的又是什么。
    我们可以申请一把锁，通过这个锁保护具体的资源，java中内置锁是synchronized