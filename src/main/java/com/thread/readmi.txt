1.demo案例
2.test关键字用法

sync（Object）
锁升级
偏向锁 -> 自旋锁 -> 重量级
首先一个线程获取到一个锁，会在这个对象头记录当前线程，如果这次线程在请求这个锁对象，发现存在对象头记录，则不会加锁，这时候是偏向锁
如果另外一个线程来获取锁，发现已经有线程占用，则请求锁的这个线程会自旋，继续占用cpu时间，jdk默认自旋10次，此时就是升级到了自旋锁
如果自旋10次，获取锁的线程还是么有释放锁，则不在自旋，进入线程等待队列，升级为重量级锁

如果线程少，执行时间短，则自旋锁
如果线程很多，执行时间也很长，就选择重量级锁

【内存模型JMM之互斥锁】，volatiledemo介绍了volatile和Happens-Before解决可见性与顺序性问题，这里说明下互斥锁解决原子性问题。

    一个或多个操作在CPU执行过程中不被中断，称为原子性。破坏原子性的主要问题就是线程切换，而在操作系统中线程切换是依赖CPU中断的，
那么是否说明禁用CPU中断就可以解决线程切换问题。但是这种方法只适用于单核CPU，如果多核CPU的话，问题依然存在。
    我们知道。Long占8个字节，就是64位，在32位的操作系统上，写操作会被分为两次操作，【写高位和写地位】，如果在单核系统，禁用了CPU中断
一个线程就会连续的执行，所以以上两次操作要么执行要么不执行。但是在多核CPU中，禁止CPU中断只能保证多个线程同时连续执行，并不能保证
【同一时刻只有一个线程执行】。如果两个线程同时【写高位】的话，就出bug了。
    如何解决呢，上面说到，同一时刻只有一个线程执行，这个又叫做【互斥】，如果可以保证对共享变量的修改是互斥的，那么问题就可以解决了。这也是
所谓的【锁】
    简单的锁模型 【加锁】临界区 【解锁】，首先，如果一个线程想进入临界区，尝试加锁，加锁成功，进入临界区，执行完毕，解锁。但是这个过程中，
忽略了一个问题，【锁】的是什么【保护】的又是什么。
    我们可以申请一把锁，通过这个锁保护具体的资源，java中内置锁是synchronized

【线程生命周期】
通常线程生命周期主要有5个状态：
    1.初始状态 - 被创建，还没有分配CPU执行，这里的创建，仅仅是编程语言上独有的，而在操作系统层面，线程还没有创建，比如java里的new Thread
    2.可运行状态 - 此时操作系统层的线程已经创建了，可以分配CPU执行了
    3.运行状态 - 如果有空闲的CPU，会分配给一个处于可运行状态的线程，被分配到CPU的线程处于运行状态
    4.休眠状态 - 线程休眠，
        在Java中，Blocked，waiting，time_waiting都属于该状态，是不能获得CPU执行权的
    5.终止状态 - 线程执行完成或者异常终止，进入这个状态的线程不会再切换其它状态，意味着线程生命周期结束

【多线程应用场景】
    要谈论这个话题，首先要清楚：为什么要使用多线程，多线程有哪些应用场景？
使用多线程本质就是为了提升性能，说到性能，可能第一时间想到的就是快，但是，这个快如何度量呢？度量性能的指标有很多，但是有两个很重要的指标：
【吞吐量】与【延迟】，【吞吐量】是指单位时间内处理请求的数量，吞吐量越大，意味着程序处理的请求越多，性能也有越好。【延迟】指发起请求到收到
响应的这个时间，一般延迟越短，程序执行的越快，性能也就越好。
    所以，我们要提升性能，主要就是降低【延迟】，提高【吞吐量】，那么如何能做到呢？这个就和多线程息息相关了。
    要想降低【延迟】，提高【吞吐量】，主要有两个方向，【优化算法】，另一个就是将【硬件的性能发挥到极致】，前者属于算法范畴，暂不展开，后者
就和多线程息息相关了。计算机有哪些硬件呢？主要有两类：【IO】与【CPU】，简单的来说，在并发领域，【提升性能本质就是提升硬件的利用率，再具体点
就是提升 IO 和 CPU 的利用率】。
    单一的硬件设备，操作系统已经已经解决了利用率问题，比如磁盘和网卡的利用率问题，利用中断机制还避免了CPU轮询IO，也提升了CPU利用了。但是在
程序使用过程中，往往都是需要 CPU 和 IO 设备配合工作的，就是说：【要解决 CPU 和 IO 综合利用率问题】，关于这个问题，操作系统没办法完美解决，
但是给了方案【多线程】
    那么多线程是如何提高利用率的呢？举个例子：假设程序的 CPU 计算和 IO 操作用时1：1，如果只有一个线程，执行 CPU 计算时， IO 设备空闲，
执行 IO 操作时， CPU 空闲，此时 CPU IO 设备的利用率是 50%，如果有两个线程，在线程A执行 CPU计算时，线程B执行 IO 操作，这样的话，利用率就可以
提升到100%了（真实场景往往达不到，还涉及到线程交互与切换问题），可以看到，如果 CPU 和 IO 设备利用率都很低，可以使用多线程来提高利用率，提升吞吐量
    在单核 CPU 中，多线程往往是用来平衡 CPU 和 IO 设备的，如果程序只有 CPU 计算，使用多线程并不能提高性能，应为会涉及到线程上线文切换。
但是在多核时，这种纯 CPU 计算的场景可以使用多线程来提升性能，因为可以降低响应时间，比如计算1到100亿数字的和，线程A可以计算1-50亿，线程B计算
剩下的之后在汇总，理论上可以比单线程提升2倍，响应降低50%，如果在2核 CPU，一个线程只能达到50%利用率，2个线程可以到达100%，也引出一个问题，
多线程下，开多少线程合适

【开多少线程合适】
    程序中一般都是 CPU 计算 和IO 操作交替执行的，由于 IO 设备对应 CPU来说很慢，所有大部分情况下，IO 操作都比 CPU 花费时间更长，对应的叫做
IO 密集型计算，和值对应的就是 CPU密集计算了，在 CPU密集计算中，使用的线程数往往建议是 CPU 核数 +1，但是在真是场景中，都是 CPU 和 IO结合的，
计算公式：最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）] ， 但是在实际应用中，这个耗时非常不好衡量，只有通过压测才可以得出来最佳的
线程开启数量。压测的时候，需要关注 CPU IO设备的利用率与性能指标间的关系（吞吐量，延迟）