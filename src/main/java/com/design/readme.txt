并发设计模式

我们提到的并发问题，一般都是在并发环境下访问操作共享变量，那么针对这个情况，有哪些方式可以避免呢，这就要聊一聊现存的并发设计模式了

1.final
    利用不变性解决并发问题，被final 修饰的变量是在编译期就完成初始化了的，并且运行期final 执行的对象是不能被改的。针对这个特性可以保证被 final 修饰
的变量的并发安全性。
    1.1.但是final也有局限，比如用 final 修饰包装类型，虽然不能修改对象的地址，但是对象的属性是可以修改的
    1.2.很多变量都是需要在运行时根本程序上线文修改变量内容的，如果使用final 的话，满足不了这些场景

2.copy-on-write
    写操作时操作新队列，在读的时候还是读老队列，在写操作完毕时将读操作的指针执行写操作队列，可以完美的避免并发问题
    2.1.但是也有局限性，只能保证最终一致，保证不了实事一致性
    2.2.可以看到在写操作时都是新建队列，然后把原队列数据拷贝，如果存在大量写操作时，就会出现大量新建队列的操作，严重影响性能。也就需要读多写少的场景

3.线程本地化
    并发问题的源头就是共享变量，那么我们可不可以不共享变量，每个线程都持有自己的变量，线程内部来维护这个值。Java Api 提供了ThreadLocal 来完成线程本地处理
    3.1.虽然ThreadLocal 很好用，但是也存在问题，首先就是容易造成内存泄漏，在使用时要特别注意，使用完毕之后及时remove()掉。Thread内部维护了ThreadLocalMap
        ThreadLocal 就是用这个Map 来保证线程私有的，这个Map 内部的Entity 实现了WeakReference（弱引用），这个Map 的key 就是 ThreadLocal，value 就是
        对应的set 的值，ThreadLocalMap 内部对这个ThreadLocal 的是弱引用，当Thread对象被回收时，ThreadLocalMap 就会被回收，那么为什么还会存在内存泄漏呢？
      在真是项目中，线程池的线程生命周期一般都很长，往往伴随程序的整个生命周期，这也就意味着Thread持有的ThreadLocalMap 一直不会被回收，所以长期下来ThreadLocalMap
      一些不用的Value 还是不能回收，导致内存泄漏，所以在用完之后要做到及时remove()
    3.2.场景局限性
        主要用来传递一些上下文参数，比如用户id等相关信息，在使用时一般是通过拦截器来实现：比如调用方法前set(),调用完之后remove() 当然set remove 都是通过拦截器实现

4.