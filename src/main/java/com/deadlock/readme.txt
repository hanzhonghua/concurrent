讲解死锁的原因与解决方案

主要用一个现实的例子来讲解。
银行转账业务，已开始使用全局锁，性能有问题，然后锁细化，细化之又因为顺序性导致死锁，然后使用jvm提供的工具
找出死锁，并优化，具体看代码示例

【死锁产生的四个必要条件】
1.互斥：共享资源X，Y只能被一个线程同时占有
    先决条件，不能破坏
2.占有等待：线程T1占有资源X在等待资源Y时候不释放X
    破坏：让线程要么同时获取两个资源，要不一直循环直到超时或者超过循环次数，增加管理员
3.不可抢占：线程T1占有资源X不可以被其它线程强制占有
    破坏：线程占有一个资源再去获取其它资源时，如果获取不到，释放占有的资源
4.循环等待：线程T1占有X等待线程T2释放占有的资源Y，同时线程T2又等待线程T1释放X
    破坏：给资源排序，顺序加锁；排序之后，无论线程T1或者T2先执行，都是先锁顺序id小的资源，所以就不存在互相等待了

针对三个破坏方案，破坏循环等待条件是代价最小也是最容易实现的方案，保证资源顺序（保证加锁顺序）即可

【wait sleep区别】
1.wait必须在同步代码块中使用，并且是Object方式，对应的有notify 和notifyAll，当多个线程竞争锁时候，没有获得锁的线程会进入等待【锁队列】，
    继续执行，如果调用wait，当前线程会进入wait对象对应的【条件等待队列】，然后会释放锁，当调用这个对象的notify或者notifyAll时候，会唤醒
    【条件等待队列】的线程，进入【锁队列】，重新争夺锁
2.sleep是Thread的一个方法，可以在同步块调用，也可不，不在同步块调用时，意思是让优先级相等或者高于该线程的线程获得CPU执行，当用在同步块中时
    不会释放锁
3.两个方法都需要捕获异常InterruptedException

【wait notify notifyAll为什么会放在Object而不放在Thread】
